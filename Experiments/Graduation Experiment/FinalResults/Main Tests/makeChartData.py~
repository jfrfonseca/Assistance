#!/usr/bin/env python
import sqlite3
import os
import sys
import math
import plotly.plotly as py
from plotly.graph_objs import *


'''results (configuration text, run text, serverIP text, scheduling text, appTouple text, response real, transfer real, execution real)'''


AVERAGE_TIME_PER_CONF_SCH_DESC = "TOTAL RESPONSE, PROCESSING TIME PER CONFIGURATION, SCHEDULE STRATEGY ON SERVER:"
AVERAGE_TIME_PER_CONF_SCH_QUERY = '''select configuration, scheduling, exp(avg(log(rsp))), exp(avg(log(exe))) from (select run, configuration, scheduling, sum(response) as rsp, sum(execution) as exe from results group by configuration, scheduling, run) group by configuration, scheduling'''


AVERAGE_TIME_PER_CONF_SERV_SCH_DESC = "TOTAL RESPONSE, PROCESSING TIME PER CONFIGURATION, SCHEDULE STRATEGY ON SERVER:"
AVERAGE_TIME_PER_CONF_SERV_SCH_QUERY = '''select configuration, serverIP, scheduling, exp(avg(log(rsp))), exp(avg(log(exe))) from (select run, configuration, serverIP, scheduling, sum(response) as rsp, sum(execution) as exe from results group by configuration, serverIP, scheduling, run) group by configuration, serverIP, scheduling'''



namesList = [AVERAGE_TIME_PER_CONF_SCH_DESC]
analisysList = [AVERAGE_TIME_PER_CONF_SCH_QUERY]


def sumDigits(conf):
	config = int(conf)/10
	total = 0
	while config >= 1:
		total += config % 10
		config /= 10
	return total


def getYvalues(xNamesList, results):
	# Gets the Y axis values
	rnroRespTimes = []
	rnroProcTimes = []
	fifoRespTimes = []
	fifoProcTimes = []
	sjfRespTimes = []
	sjfProcTimes = []
	# For each configuration
	for index, conf in enumerate(xNamesList):
		# scheOnServer, response, execution
		times = [(lin[2], lin[3], lin[4]) for lin in results if lin[0] == conf]
		timesDict = {}
		for itm in times:
			# The values for each schedule
			timesDict[itm[0]] = (itm[1], itm[2])
		if "RNRO" in [conf[0] for conf in times]:
			rnroRespTimes.append(float(timesDict["RNRO"][0]))
			rnroProcTimes.append(float(timesDict["RNRO"][1]))
		else:
			rnroRespTimes.append(0)
			rnroProcTimes.append(0)
		if "FIFO" in [conf[0] for conf in times]:
			fifoRespTimes.append(float(timesDict["FIFO"][0]))
			fifoProcTimes.append(float(timesDict["FIFO"][1]))
		else:
			fifoRespTimes.append(0)
			fifoProcTimes.append(0)
		if "SJF" in [conf[0] for conf in times]:
			sjfRespTimes.append(float(timesDict["SJF"][0]))
			sjfProcTimes.append(float(timesDict["SJF"][1]))
		else:
			sjfRespTimes.append(0)
			sjfProcTimes.append(0)
	return 	rnroRespTimes, rnroProcTimes, fifoRespTimes, fifoProcTimes, sjfRespTimes, sjfProcTimes


def getDataCols(results, allConfs):
	respCol = []
	procCol = []
	nCols = sumDigits(allConfs[0])
	# results is a select configuration, serverIP, scheduling, exp(avg(log(rsp))), exp(avg(log(exe)))
	# for each configuration, in order
	for conf in sorted(allConfs, key=lambda x: int(x)):
		# data is a [(configuration, scheduling, exp(avg(log(rsp))), exp(avg(log(exe))))]
		currentCol = 0
		respAvg = 0
		procAvg = 0
		# for each line of data with the given configuration, in the order: RNRO, FIFO, SJF
		for serverData in sorted([(dat[2], dat[3], dat[4], ) for dat in results if dat[0] == conf],
							key=lambda x: ["RNRO", "FIFO", "SJF"].index(x[0])):
			print serverData
			print currentCol
			print respCol
			if len(respCol) == nCols:
				respCol[currentCol].append(serverData[1])
				procCol[currentCol].append(serverData[2])				
			else:
				respCol.append([serverData[1]])
				procCol.append([serverData[2]])
			respAvg += math.log(serverData[1])
			procAvg += math.log(serverData[1])
			currentCol += 1
			
			
			respCol.append([math.exp(respAvg/nCols)])
			procCol.append([math.exp(procAvg/nCols)])

	return respCol, procCol


def sqliteLog(val):
	return math.log(val)


def sqliteExp(val):
	return math.exp(val)


if __name__ == '__main__':
	alldb = sqlite3.connect('allResults')
	alldb.create_function("log", 1, sqliteLog)
	alldb.create_function("exp", 1, sqliteExp)
	allCursor = alldb.cursor()
	if len(sys.argv) > 1 and sys.argv[1] == "--import":
		allCursor.execute("CREATE TABLE results (configuration text, run text, serverIP text, scheduling text, appTouple text, response real, transfer real, execution real)")
		for dayExperiment in (next(os.walk('./'))[1]):
			allCursor.execute("attach '"+dayExperiment+"/experimentResults' as merged;")
			allCursor.execute("insert into results select * from merged.results;")
			allCursor.execute("detach database merged;")

		if len(sys.argv) > 1 and sys.argv[1] == "--print":
			for index, analisys in enumerate(analisysList):
				allCursor.execute(analisys)
				results = allCursor.fetchall()
			# Sorts the results list per configuration
			sorted(results, key=lambda x: int(x[0]))
			print "<BEGIN>"
			print namesList[index]
			for line in results:
				print line
			print "<END>"
			alldb.close()
	
	if len(sys.argv) > 1 and sys.argv[1] == "--stack":
		for index, analisys in enumerate(analisysList):
			allCursor.execute(analisys)
			results = allCursor.fetchall()
		# Sorts the results list per configuration
		sorted(results, key=lambda x: int(x[0]))
		'''
		Stacked Bar Charts of time of execution per configuration, per scheduling - 9 Servers, 1 Client
		'''
		# Gets the X axis names
		xNamesList = sorted(list(set([str(config[0]) for config in results if str(config[0])[-1] == "1" and sumDigits(str(config[0])) == 9])), key=lambda x: int(x))
		rnroRespTimes, rnroProcTimes, fifoRespTimes, fifoProcTimes, sjfRespTimes, sjfProcTimes = getYvalues(xNamesList, results)
		# Prints the Response Times Graph
		xNamesList = ["Conf. "+config for config in xNamesList]
		responseRNRO = Bar(
			x=xNamesList,
			y=rnroRespTimes,
			name="Response Time RNRO"
		)
		responseFIFO = Bar(
			x=xNamesList,
			y=fifoRespTimes,
			name="Response Time FIFO"
		)
		responseSJF = Bar(
			x=xNamesList,
			y=sjfRespTimes,
			name="Response Time SJF"
		)
		data = Data([responseRNRO, responseFIFO, responseSJF])
		layout = Layout(
			barmode='stack'
		)
		responseTimesGraph = Figure(data=data, layout=layout)
		plot_url = py.plot(responseTimesGraph, filename='Response Times Per Schedule Strategy and Configuration, 9 Servers, 1 Client')
	
		processingRNRO = Bar(
			x=xNamesList,
			y=rnroProcTimes,
			name="Processing Time RNRO"
		)
		processingFIFO = Bar(
			x=xNamesList,
			y=fifoProcTimes,
			name="Processing Time FIFO"
		)
		processingSJF = Bar(
			x=xNamesList,
			y=sjfProcTimes,
			name="Processing Time SJF"
		)
		data = Data([processingRNRO, processingFIFO, processingSJF])
		layout = Layout(
			barmode='stack'
		)
		processingTimesGraph = Figure(data=data, layout=layout)
		plot_url = py.plot(processingTimesGraph, filename='Processing Times Per Schedule Strategy and Configuration, 9 Servers, 1 Client')
	
		'''
		Stacked Bar Charts of time of execution per configuration, per scheduling - 4 Servers, 1 Client
		'''
		# Gets the X axis names
		xNamesList = sorted(list(set([str(config[0]) for config in results if str(config[0])[-1] == "1" and sumDigits(str(config[0])) == 4])), key=lambda x: int(x))
		rnroRespTimes, rnroProcTimes, fifoRespTimes, fifoProcTimes, sjfRespTimes, sjfProcTimes = getYvalues(xNamesList, results)
		# Prints the Response Times Graph
		xNamesList = ["Conf. "+config for config in xNamesList]
		responseRNRO = Bar(
			x=xNamesList,
			y=rnroRespTimes,
			name="Response Time RNRO"
		)
		responseFIFO = Bar(
			x=xNamesList,
			y=fifoRespTimes,
			name="Response Time FIFO"
		)
		responseSJF = Bar(
			x=xNamesList,
			y=sjfRespTimes,
			name="Response Time SJF"
		)
		data = Data([responseRNRO, responseFIFO, responseSJF])
		layout = Layout(
			barmode='stack'
		)
		responseTimesGraph = Figure(data=data, layout=layout)
		plot_url = py.plot(responseTimesGraph, filename='Response Times Per Schedule Strategy and Configuration, 4 Servers, 1 Client')
	
		processingRNRO = Bar(
			x=xNamesList,
			y=rnroProcTimes,
			name="Processing Time RNRO"
		)
		processingFIFO = Bar(
			x=xNamesList,
			y=fifoProcTimes,
			name="Processing Time FIFO"
		)
		processingSJF = Bar(
			x=xNamesList,
			y=sjfProcTimes,
			name="Processing Time SJF"
		)
		data = Data([processingRNRO, processingFIFO, processingSJF])
		layout = Layout(
			barmode='stack'
		)
		processingTimesGraph = Figure(data=data, layout=layout)
		plot_url = py.plot(processingTimesGraph, filename='Processing Times Per Schedule Strategy and Configuration, 4 Servers, 1 Client')
		alldb.close()
		
	if len(sys.argv) > 1 and sys.argv[1] == "--group":
		namesList = [AVERAGE_TIME_PER_CONF_SERV_SCH_DESC]
		analisysList = [AVERAGE_TIME_PER_CONF_SERV_SCH_QUERY]
		
		for index, analisys in enumerate(analisysList):
			allCursor.execute(analisys)
			results = allCursor.fetchall()

		# Sorts the results list per configuration
		sorted(results, key=lambda x: int(x[0]))
		'''
		Stacked Bar Charts of time of execution per configuration, per server, per scheduling - 4 Servers, 1 Client
		'''
		# Gets the X axis names
		allConfs = sorted(list(set([str(config[0]) for config in results if str(config[0])[-1] == "1" and sumDigits(str(config[0])) == 4])), key=lambda x: int(x))
		respCol, procCol = getDataCols(results, allConfs)
		# Prints the Response Times Graph
		responseList = []
		processingList = []
		xNamesList = ["Conf. "+config for config in allConfs]
		for col in range(len(respCol)-1):
			responseList.append(Bar(
				x=xNamesList,
				y=respCol[col],
				name="Response Time server "+str(col)
			))
			processingList.append(Bar(
				x=xNamesList,
				y=procCol[col],
				name="Processing Time server "+str(col)
			))
		responseList.append(Bar(
			x=xNamesList,
			y=respCol[-1],
			name="Average in Configuration"
		))
		processingList.append(Bar(
			x=xNamesList,
			y=procCol[-1],
			name="Average in Configuration"
		))
			
		data = Data(responseList)
		layout = Layout(
			barmode='group'
		)
		responseTimesGraph = Figure(data=data, layout=layout)
		plot_url = py.plot(responseTimesGraph, filename='Response Times Per Server per Schedule Strategy, 4 Servers, 1 Client')
		
		data = Data(processingList)
		layout = Layout(
			barmode='group'
		)
		processingTimesGraph = Figure(data=data, layout=layout)
		plot_url = py.plot(responseTimesGraph, filename='Processing Times Per Server per Schedule Strategy, 4 Servers, 1 Client')
	
		alldb.close()
	

